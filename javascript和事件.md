###javascript和事件 2015/08/03

>[原文](http://yujiangshui.com/javascript-event/)感谢提供答案。

###javascript和事件
>与浏览器进行交互的时候，浏览器就会触发各种事件。比如当我们打开某一个网页的时候，浏览器加载完成了这个网页，就会触发一个load事件；当我们点击页面中的某一个“地方”,浏览器就会在那个地方触发一个click事件。

>这样，我们就可以编写javascript，通过监听某一个事件，来实现某些功能扩展。例如监听load事件，显示欢迎信息，那么当浏览器加载完一个网页之后，就会显示欢迎信息。

>下面就来介绍一下事件。

###基础事件操作

####监听事件

1.HTML内联属性（避免使用）
>HTML元素里面直接填写事件有关属性，属性值为javascript代码，即可在触发该事件的时候，执行属性值的内容。

>例如：
```
	<button onclick="alert('你点击了这个按钮')">点击这个按钮</button>
```
>onclick属性表示触发click，属性值的内容（javascript代码）会在单击该HTML节点时执行。

>显而易见，使用这种方法，javascript代码必须与HTML代码耦合在一起，不便于维护和开发。所以除非在必须使用的情况(例如统计链接点击数据)下，尽量避免使用这种方法。

2.Dom属性绑定
>也可以直接设置Dom属性来指定某个事件对应的处理函数，这个方法比肩简单：
```
	element.onclick=function(event){
		alert("你点击了这个函数");
	}
```
上面代码就是监听element节点的click事件。它比较简单易懂，而且有较好的兼容性。但是也有缺陷，因为直接赋值给对应属性，如果你在后面的代码中再次element绑定一个回调函数，会覆盖之前的回调函数的内容。 

>虽然也可以用一些方法实现多个绑定，但是还是推荐下面的标准事件监听函数。

3.使用事件监听函数
>标准的事件监听函数如下：
```
element.addEventListener(<event-name>,<callback>,<use-captuer>)
```
表示在element这个对象上面添加一个事件监听器，当监听到有<event-name>事件发生的时候，调用<callback>这个回调函数。至于<use-capture>这个参数，表示该事件监听是在“捕获”阶段中监听（设置为ture）还是在冒泡阶段中监听（设置为false）。关于捕获和冒泡，我们会在下面讲解。

>用标准事件监听函数改写上面的例子：
```
var btn=document.getElementsByTayName('button');
btn[0].addEventListener('click',function(){
	alert('你点击了这个按钮');
},false);
```
这里最好是为HTML结构定义个ID或者Class属性，方便选择，在这里只作为显示使用。

4.移除事件监听
>当我们为某个元素绑定了一个事件，每次触发这个事件的时候，都会执行事件绑定的回调函数。如果我们想解除绑定，需要使用removeEventListenet方法
```
element.removeEventListenet(<event-name>,<callback>,<use-capture>);
```
需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。例如：
```
var fun=function(){
	//function logic
}
element.addEventListener('click',fun,false);
element.removeEventListener('click',fun,false);
```

####事件触发过程
>在上面大体了解了事件是什么、如何监听并执行某些操作，但我们对事件触发整个过程还不够了解。

>下面就是事件的触发过程，借用了w3c的图片

><img src="img/event0.png" alt="">

1.捕获阶段（Capture Phase）
>当我们在dom树的某个节点发生了一些操作（例如单击、鼠标移动上去），就会有一个事件发射过去。这个事件从window发出，不断经过下级节点直到目标节点。在到达目标节点之前的过程，就是捕获阶段（Captrue Phase）

>所有经过的节点，都会触发这个事件。捕获阶段的任务就是建立这个事件传递路线，以便后面冒泡阶段顺着这条路返回window。

>监听某个在捕获阶段触发的事件，需要再事件监听函数传递第三个参数true。
```
element.addEventListener(<event-name>,<callback>,true);
```
但一般使用时，我们往往传递false，会在后面说明原因。

2.目标阶段（Target Phase）
>当事件跑啊跑，跑到了事件触发目标节点那里，最终在目标节点上面触发这个事件，就是目标阶段。

>需要注意的是，事件触发的目标节总是最底层的节点。比如你点击一段文字，你以为你的事件目标节点在div上，但实际上触发在```<p>```、```<span>```等子节点上。例如：
```
document.addEventListener("click",function(e){
	alert(e.target.tagName);
},false);
```
>在demo中，我监听单击事件，将目标节点的tagname弹出来。当你点击加粗字体时，事件的目标节点就为最底层<string>节点。

3.冒泡阶段（Buddling Phase）
>当事件达到目标节点之后，就会沿着原来返回，由于这个过程类似水泡从底部浮到顶部，所有称作冒泡阶段。

>在实际使用过程中，你并不需要把事件监听函数准确绑定到最底层的节点也是可以正常工作。比如在上例，你想为这个```<div>```绑定单击时的回调函数，你无须为这个```<div>```下面的所有子节点全部绑定单击事件，只需要为```<div>```这一个节点绑定即可。因为发生它子节点的单击事件，都会冒泡上去，发生在```<div>```上面。

4.为什么不用第三个参数true
>介绍完上面三个事件触发阶段，我们来看下这个问题。

>所有介绍事件的文章都会说，在使用addEventListener函数来监听事件时，第三个参数设置为false，这样监听事件时只会监听事件冒泡阶段发生的事件。

>这是因为IE浏览器不支持在捕获阶段监听事件，为了统一而设置的，毕竟IE浏览器的份额是不可忽略的。

>IE浏览器在事件这方面与标准还有一些其他差异，我们会在后面集中介绍。

####使用事件代理（Event Delegate）提升性能。
>因为事件有冒泡机制，所有子节点的事件都会顺着父级节点跑回去，所以我们可以通过监听父级节点来实现监听子节点的功能，这就是事件代理。

>使用事件代理的主要两个优势：
>1.减少事件绑定，提示性能。之前你需要绑定一堆子节点，而现在绑定一个父节点即可。减少了绑定事件监听函数的数量。
>2.动态变化的DOM节点结构，仍然可以监听。当一个DOM动态创建之后，不会带有任何事件监听，除非你重新执行事件绑定函数，而使用事件监听无须担忧这个问题。
```
$(".ul1 a").on("click",function(){
	alert('正在监听');
});
$(".ul2").on("click","a",function(){
	alert('正在监听');
});
$(".add-more-items").on("click",function(){
	var item=$('<li><a href="#">我是动态新增节点</a></li>');
	$(".ul1,.ul2").append(item)
})
```

>上面例子中，为了简便，我使用jquery来实现普通事件绑定和事件代理。我的目标是监听所有a链接的单击事件，.ul1是常规的事件绑定方法，jquery会循环每一个.ul>a结构并绑定事件监听函数。.ul2则是事件监听的方法，jquery只为.ul2结构绑定事件监听函数，因为.ul2下面可能会有很多无关节点也会触发click事件，所以我在on函数里传递了第二个参数，表示只监听a子节点事件。

>它们都可以正常工作，但是当我动态创建新dom结构的时候，第一个ul问题就出现了，新创建结构虽然还是.ul1>a，但是没有绑定事件，所以无法执行回调。而第二个ul工作的很好，因为新创建的dom，它的事件会冒泡到父级节点进行处理。

>如果使用原生的方法实现事件代理，需要注意过滤非目标节点，可以通过id、class或者tagname等等，例如：
```
element.addEventListener("click",function(){
	//判断是否是a节点
	if(event.target.tagName=="a"){
		//a的一些交互
	}
},false);
```

####停止事件冒泡（stopPropagation）
>所有的事情都会有对立面，事件的冒泡阶段虽然看起来很好，也会有不适合的场所。比较复杂的应用，由于事件监听比较复杂，可能会希望只监听发生在具体节点的事件。这个时候就需要停止事件冒泡、

>停止事件冒泡需要使用事件对象的stopPropagation方法，具体代码如下：
```
element.addEventListener('click',function(){
	event.stopProopagation();
})
```